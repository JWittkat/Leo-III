package datastructures.internal

import datastructures.Pretty


/**
 * Abstract interface for generation of various terms that can be
 * displayed in the internal language.
 * Terms are generated by
 *
 * {{{s,t ::= c (Atom)
 *       | \c:tau.t (term abstraction)
 *       | s t (term application)
 *       | /\a.t (type abstraction)
 *       | s tau (type application)}}}
 *
 * where `c` is some symbol (constant) and `tau` is a type (see `HOLType`).
 *
 * @author Alexander Steen
 * @since 21.05.2014
 * @note Updated 02.06.2014 Cleaned up method set, lambda terms always have types
 */
abstract class Term extends Pretty {
  // Predicates on terms
  val isAtom: Boolean
  val isTermApp: Boolean
  val isTermAbs: Boolean
  val isTypeApp: Boolean
  val isTypeAbs: Boolean


  // Queries on terms
  def ty: Type
  def freeVars: Set[Term]
  def herbrandUniverse: Set[Term]
  // Substitutions
  def substitute(what: Term, by: Term): Term
  def substitute(what: List[Term], by: List[Term]): Term = {
    require(what.length == by.length, "Substitution list do not match in length.")
    what.zip(by).foldRight(this)({case ((w,b), t:Term) => t.substitute(w,b)})
  }
  protected[internal] def instantiateBy(by: Type) = instantiate(1,by)
  protected[internal] def instantiate(scope: Int, by: Type): Term
  // Other operations
  def betaNormalize: Term

  def foldRight[A](symFunc: Signature#Key => A)
             (boundFunc: (Type, Int) => A)
             (absFunc: (Type, A) => A)
             (appFunc: (A,A) => A)
             (tAbsFunc: A => A)
             (tAppFunc: (A, Type) => A): A

  protected[internal] def inc(scopeIndex: Int): Term
}


object Term {
  def mkAtom = SymbolNode(_)
  def mkBound = BoundNode(_,_)
  def mkTermApp = ApplicationNode(_,_)
  def mkTermAbs = AbstractionNode(_, _)
  def mkTypeApp(left: Type, right: Type): Term = ???
  def mkTypeAbs(body: Term): Term = ???

  def \(hd: Type, body: Term): Term = ???

  def /\(body: Term): Term = ???
}

