package datastructures.internal

import datastructures.Pretty
import scala.language.implicitConversions

/**
 * Abstract interface for generation of various terms that can be
 * displayed in the internal language.
 * Terms are generated by
 *
 * {{{s,t ::= c (Atom)
 *       | \c.t (term abstraction)
 *       | s t (term application)
 *       | /\a.t (type abstraction)
 *       | s tau (type application)}}}
 *
 * where `c` is some symbol (constant) and `tau` is a type (see `HOLType`).
 *
 * @author Alexander Steen
 * @since 21.05.2014
 */
abstract sealed class Term extends Pretty {
  // Predicates on terms
  val isAtom: Boolean
  val isTermApp: Boolean
  val isTermAbs: Boolean
  val isTypeApp: Boolean
  val isTypeAbs: Boolean
  def isApplicable(arg: Term): Boolean

  // Queries on terms
  def getType: Option[Type]
  def _getType: Type = getType.get
  def freeVars: Set[Signature#Key]
  def herbrandUniverse: Set[Term]
  // Substitutions
  def substitute(what: Term, by: Term): Term
  def substitute(what: List[Term], by: List[Term]): Term = {
    require(what.length == by.length, "Substitution list do not match in length.")
    what.zip(by).foldRight(this)({case ((w,b), t:Term) => t.substitute(w,b)})
  }
  protected[internal] def inc: Term = this
  protected[internal] def dec: Term = this

  def scope: Int

  // Other operations
  def betaNormalize: Term
  // compare, order...
}

protected[internal] case class Atom(id: Signature#Key) extends Term {
  // Pretty printing
  import Signature.{get => signature}
  val sig = signature
  def pretty = sig.getMeta(id).getName

  // Predicates on terms
  val isAtom = true
  val isTermApp = false
  val isTermAbs = false
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = sig.getMeta(id).getType match {
    case Some(ty) if ty.isFunType  => ty._funDomainType == arg._getType
    case _ => false
  }

  // Queries
  def getType: Option[Type] = sig.getMeta(id).getType
  def freeVars: Set[Signature#Key] = Set(id)
  def herbrandUniverse: Set[Term] = Set.empty

  // Substitutions
  def substitute(what: Term, by: Term): Term = what match {
    case Atom(a) if a == id => by
    case _                  => this
  }

  def scope = -1

  def betaNormalize: Term = this // atoms are in Î²-nf
}

protected[internal] case class TermAbs(paramType: Type, body: Term) extends Term {
  // Pretty printing
  def pretty = "(\\" + paramType.pretty + ". " + body.pretty + ")"

  // Predicates on terms
  val isAtom = false
  val isTermApp = false
  val isTermAbs = true
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = arg.getType match {
    case None     => true // was machen wir hier?
    case Some(ty) => ty == paramType
  }

  // Queries
  def getType: Option[Type] = Some(Type.mkFunType(paramType, body._getType))
  def freeVars: Set[Signature#Key] = body.freeVars
  def herbrandUniverse: Set[Term] = ???

  // Substitutions
  def substitute(what: Term, by: Term): Term = what match {
    case DeBruijnIndex(_,i) if i <= body.scope => TermAbs(paramType, body.substitute(what.inc,by.inc))
    case _ => TermAbs(paramType, body.substitute(what.inc,by.inc))
  }
//
  override def dec = TermAbs(paramType, body.dec)
  override def inc = TermAbs(paramType, body.inc)

  def scope = 1+ body.scope

  def betaNormalize: Term = TermAbs(paramType, body.betaNormalize)
}

protected[internal] case class TermApp(left: Term, right: Term) extends Term {
  // Pretty printing
  def pretty = "(" + left.pretty + " " + right.pretty + ")"

  // Predicates on terms
  val isAtom = false
  val isTermApp = true
  val isTermAbs = false
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = betaNormalize._getType match {
    case ty if ty.isFunType => arg._getType == ty._funDomainType
    case _ => false
  }

  // Queries
  def getType: Option[Type] = Some(left._getType._funCodomainType)

  def freeVars: Set[Signature#Key] = left.freeVars ++ right.freeVars
  def herbrandUniverse: Set[Term] = ???

  // Substitutions
  def substitute(what: Term, by: Term): Term = TermApp(left.substitute(what, by), right.substitute(what, by))

  override def dec = TermApp(left.dec, right.dec)
  override def inc = TermApp(left.inc, right.inc)

  def scope = left.scope.max(right.scope)

  def betaNormalize: Term = {
    val leftNF = left.betaNormalize
    val rightNF = right.betaNormalize
    leftNF match {
      case TermAbs(ty, body) => body.dec.substitute(DeBruijnIndex(ty, -1), rightNF)
      case _ => TermApp(leftNF, rightNF)
    }
  }

}

protected[internal] case class DeBruijnIndex(boundType: Type, i: Int) extends Term {
  // Pretty printing
  def pretty = i.toString

  // Predicates on terms
  val isAtom = false
  val isTermApp = true
  val isTermAbs = false
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = arg.getType match {
    case Some(ty) if boundType.isFunType => boundType._funDomainType == ty
    case _ => false
  }

  // Queries
  def getType: Option[Type] = Some(boundType)

  def freeVars: Set[Signature#Key] = Set.empty
  def herbrandUniverse: Set[Term] = ???

  // Substitutions
  def substitute(what: Term, by: Term): Term = what match {
    case DeBruijnIndex(_,j) if i == j => by
    case _ => this
  }

  override def dec = DeBruijnIndex(boundType, i-1)
  override def inc = DeBruijnIndex(boundType, i+1)

  def scope = -1

  def betaNormalize: Term = this
}


object Term {
  def mkAtom = Atom(_)
  def mkBound = DeBruijnIndex(_,_)
  def mkTermApp = TermApp(_,_)
  def mkTermAbs = TermAbs(_, _)
  def mkTypeApp(left: Type, right: Type): Term = ???
  def mkTypeAbs(hd: Variable, body: Term): Term = ???

  def \(hd: Type, body: Term): Term = ???

  def /\(hd: Variable, body: Term): Term = ???

  implicit def intToBoundVar(i: Int, t: Type): Term = mkBound(t,i)
}
