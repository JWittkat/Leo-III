package datastructures.internal

import datastructures.Pretty

/**
 * Created by lex on 29.04.14.
 */
abstract sealed class Term extends Pretty {

  // Predicates on terms
  def isVar: Boolean = false
  def isConst: Boolean = false
  def isTermApp: Boolean = false
  def isTermAbs: Boolean = false
  def isTypeApp: Boolean = false
  def isTypeAbs: Boolean = false
  def isApplicable(arg: Term): Boolean

  // Queries on terms
  def getType: Option[Type]
  def _getType: Type = getType.get
  def getFreeVars: Set[Variable]

  // Substitutions
  // ...

  // Other operations
  def betaNormalize: Term
  // compare, order...
}

protected[internal] case class TermApp(left: Term, right: Term) extends Term {
  def pretty = left.pretty + " " + right.pretty

  override def isTermApp = true
  def isApplicable(arg: Term): Boolean = ???

  def getType: Option[Type] = ???
  def getFreeVars: Set[Variable] = left.getFreeVars ++ right.getFreeVars

  def betaNormalize: Term = this // do not normalize yet

}


/**
 * Abstract interface for generation of various terms that can be
 * displayed in the internal language.
 * Terms are generated by
 *
 * {{{s,t ::= c (Constant)
 *       | \c.t (term abstraction)
 *       | s t (term application)
 *       | /\a.t (type abstraction)
 *       | s tau (type application)}}}
 *
 * where `c` is some symbol (constant) and `tau` is a type (see `HOLType`).
 */
object Term {
  def mkConst(identifier: Int): Term = ???
  def mkTermApp(left: Term, right: Term): Term = ???
  def mkTermAbs(hd: Variable, body: Term): Term = ???
  def mkTypeApp(left: Type, right: Type): Term = ???
  def mkTypeAbs(hd: Variable, body: Term): Term = ???

  def \(hd: Variable, body: Term): Term = ???

  def /\(hd: Variable, body: Term): Term = ???
}
