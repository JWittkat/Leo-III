package datastructures.internal

import datastructures.Pretty

/**
 * Created by lex on 29.04.14.
 */
abstract sealed class Term extends Pretty {
  // Predicates on terms
  val isVar: Boolean
  val isConst: Boolean
  val isTermApp: Boolean
  val isTermAbs: Boolean
  val isTypeApp: Boolean
  val isTypeAbs: Boolean
  def isApplicable(arg: Term): Boolean

  // Queries on terms
  def getType: Option[Type]
  def _getType: Type = getType.get
  def freeVars: Set[Variable]
  def herbrandUniverse: Set[Term]
  // Substitutions
  // ...

  // Other operations
  def betaNormalize: Term
  // compare, order...
}

protected[internal] case class Atom(id: Signature#Key) extends Term {
  // Pretty printing
  import Signature.{get => signature}
  val sig = signature
  def pretty = sig.getMeta(id).getName

  // Predicates on terms
  val isVar = sig.isVarSymbol(id)
  val isConst = sig.isConstSymbol(id)
  val isTermApp = false
  val isTermAbs = false
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = ???

  // Queries
  def getType: Option[Type] = sig.getMeta(id).getType
  def freeVars: Set[Variable] = ???
  def herbrandUniverse: Set[Term] = ???

  def betaNormalize: Term = this // do not normalize yet
}

protected[internal] case class TermAbs(body: Term) extends Term {// hier fehlt type!
  // Pretty printing
  def pretty = "\\." + body.pretty

  // Predicates on terms
  val isVar = false
  val isConst = false
  val isTermApp = true
  val isTermAbs = false
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = ???
  
  // Queries
  def getType: Option[Type] = ???
  def freeVars: Set[Variable] = ???
  def herbrandUniverse: Set[Term] = ???

  def betaNormalize: Term = this // do not normalize yet
}

protected[internal] case class TermApp(left: Term, right: Term) extends Term {
  // Pretty printing
  def pretty = left.pretty + " " + right.pretty

  // Predicates on terms
  val isVar = false
  val isConst = false
  val isTermApp = true
  val isTermAbs = false
  val isTypeApp = false
  val isTypeAbs = false
  def isApplicable(arg: Term): Boolean = ???

  // Queries
  def getType: Option[Type] = ???
  def freeVars: Set[Variable] = left.freeVars ++ right.freeVars
  def herbrandUniverse: Set[Term] = ???

  def betaNormalize: Term = this // do not normalize yet

}


/**
 * Abstract interface for generation of various terms that can be
 * displayed in the internal language.
 * Terms are generated by
 *
 * {{{s,t ::= c (Constant)
 *       | \c.t (term abstraction)
 *       | s t (term application)
 *       | /\a.t (type abstraction)
 *       | s tau (type application)}}}
 *
 * where `c` is some symbol (constant) and `tau` is a type (see `HOLType`).
 */
object Term {
  def mkConst(identifier: Int): Term = ???
  def mkTermApp(left: Term, right: Term): Term = ???
  def mkTermAbs(hd: Variable, body: Term): Term = ???
  def mkTypeApp(left: Type, right: Type): Term = ???
  def mkTypeAbs(hd: Variable, body: Term): Term = ???

  def \(hd: Variable, body: Term): Term = ???

  def /\(hd: Variable, body: Term): Term = ???
}
